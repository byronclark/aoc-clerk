^{:nextjournal.clerk/visibility :hide-ns}
(ns solutions.2024.day11
  {:nextjournal.clerk/toc true}
  (:require
   [better-cond.core :as bc]
   [clojure.java.io :as io]
   [util :as u]
   [nextjournal.clerk :as clerk]
   [clojure.string :as str]))

;; # Problem
{:nextjournal.clerk/visibility {:code :hide :result :show}}
(clerk/html (u/load-problem "11" "2024"))
{:nextjournal.clerk/visibility {:code :show :result :show}}

;; # Solution
;;
;; Load and parse our input.
(def input (-> (io/resource "inputs/2024/day11.txt")
               slurp
               (str/split #"\s+")
               (#(mapv parse-long %))))

;; And our test input
(def test-input [125 17])

{:nextjournal.clerk/visibility {:code :show :result :hide}}
;; ## Part 1
;;
;; Time to write blink. Let's start with what happens to each stone.
(defn next-stone
  [stone]
  (bc/cond
    (zero? stone)
    [1]

    :let [as-str (str stone)
          len (count as-str)]
    (even? len)
    (let [half (quot len 2)]
      [(parse-long (subs as-str 0 half))
       (parse-long (subs as-str half))])

    :else
    [(* 2024 stone)]))

;; And then to update all of the stones
(defn blink
  [stones]
  (mapcat next-stone stones))

(defn part-1
  [stones]
  (->> (range 25)
       (reduce (fn [stones _] (blink stones))
               stones)
       count))

;; Which gives our test input answer
{:nextjournal.clerk/visibility {:code :hide :result :show}}
(part-1 test-input)

;; And the answer for the full input
(part-1 input)

{:nextjournal.clerk/visibility {:code :show :result :hide}}
;; ## Part 2
;;
;; And that naive solution isn't going to work for blinking more times.
;;
;; I think the trick is that the order doesn't really matter since we're only figuring out
;; how many stones there are. Which means we can calculate each value present *once* and
;; then increment counters for the new values.
(defn blink-by-count
  "Returns an updated count of each stone value after blinking.

  Takes a map of stone->count (as generated by frequencies)"
  [stone-counts]
  (reduce (fn [counts [stone n]]
            (reduce (fn [counts after-stone]
                      (update counts after-stone (fnil + 0) n))
                    counts
                    (next-stone stone)))
          {}
          stone-counts))

(defn part-2
  [stones]
  (->> (range 75)
       (reduce (fn [stones _] (blink-by-count stones))
               (frequencies stones))
       vals
       (apply +)))

;; Which gives our test input answer
{:nextjournal.clerk/visibility {:code :hide :result :show}}
(part-2 test-input)

;; And our full answer
(part-2 input)
